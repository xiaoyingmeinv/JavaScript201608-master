1.
Object是所有对象数据类型的基类：任何一个对象，通过__proto__最终都能找到这个基类Object;
每个类都是函数数据类型；
每个实例都是对象数据类型；
实例 instanceOf Object ->true
2.
prototype原型，是用来存放公有的属性和方法；（每个实例都可以使用的）
构造函数：是用来存放私有的属性和方法；（每个实例只能自己使用自己私有的）
3.原型模式的基础：
每个函数数据类型，都天生自带一个属性，叫prototype，prototype是个对象
prototype这个对象上，天生自带一个属性叫constructor
每个对象数据类型上，都自带一个属性，叫__proto__，他指向当前实例所属类的原型；
4.__proto__它是原型链：
__proto__在IE下受到保护，禁止用户通过__proto__去修改类的公有方法；
每一个实例，都可以通过__proto__去修改所有公有的属性和方法；
。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。
5.批量操作公有属性，可以用{};
用{}的时候，一定要注意两点：
    1.constructor会有问题，我们一定要重写constructor的指向；
    2.不能批量删除系统内置类的公有方法；（但可以一个个的删除）
6.关于链式操作：需要明白你的返回值是什么，才能继续以后的操作；返回值是数组的话，才能使用数组的常用方法，返回值是数字的话，只能使用数字的常用方法；
7.call是用来改变this指向的；
call()中第一个参数：用来改变this指向
call()中从第二个参数开始，相当于给call点前面的函数，从左往右一个个的传参；
8.面向对象的继承：
1）原型链的继承：把父类私有+公有的属性和方法，都给了子类公有的；（让子类.prototype=父类的实例）
2）call继承：把父类私有的属性和方法，给了子类私有的属性和方法；（注意：通过call改变this指向）
3）冒充继承：把父类私有+公有的属性和方法，都给了子类私有的；（把父类的实例克隆一份一模一样的给了子类中的实例）
4）混合继承1：call继承+原型链继承
call继承，把父类私有的，继承到了子类私有的--应该在子类的构造函数中进行继承；
原型链继承，把父类私有+公有的，继承到了子类共有的--应该在子类.prototype上进行继承；
问题：父类私有的 既在子类私有的，也在子类公有的；
5）混合继承2：call继承+拷贝继承；
call继承：在子类的构造函数中继承，一定要改变this指向；（通过call）;
拷贝继承：extend(新对象，old对象);
6)寄生式组合继承：call继承+Object.create()的思想；
function myCreate(obj){//把obj作为一个实例的原型，最后返回的实例；
    function Tmp(){};//创建一个空类
    Tmp.prototype=obj;//让这个空类的原型指向obj这个对象
    return new Tmp;//返回一个实例
}
9.Object.prototype上的公有方法：
hasOwnProperty：判断是否为私有属性
obj.isPrototypeOf(obj2) obj是否在obj2的原型链上；
propertyIsEnumerable：是否可枚举，只能枚举实例上自定义的属性和方法；（配合for in循环）









