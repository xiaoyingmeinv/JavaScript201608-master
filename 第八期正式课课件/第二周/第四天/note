1.什么是正则： 正则用来操作（匹配和捕获）字符串的一系列规则；
匹配：判断你是否符合我的规则： 返回值：布尔值； test
捕获：把符合我们规则的内容拎出来； 拿到的：字符串；
正则只会跟字符串打交道；
2.正则创建的两种方式：字面量 和 实例
两种创建方式的区别：
1）实例创建时，特殊含义的字符需要转义（\）；
2）实例创建可以进行变量的拼接，但是字面量方式创建，不能拼接变量；
3.正则由两部分组成：元字符 和 修饰符
一 元字符包含：代表特殊意义的元字符 和 代表次数的量词元字符
    代表特殊意义的元字符：
        \ 转义字符
        | 或
        () 分组
        . 除了\n以外的其他字符
        \n 换行（一般用在控制台的换行）
        \b 开头结尾和空格
        ^
        $

        \d 数字  \w 数字字母下划线  \s 空格
        \D 非数字 \W非数字字母下划线 \S 非空格

        [abc] abc三个中的任何一个 [^abc] 除了abc这三个的任何一个；
        [a-z] 字母中的任何一个    [^a-z] 非字母
    代表次数的量词元字符：
    *  0到多
    +  1到多
    ？ 0次或1次；
    {n} 正好几次
    {n,} 至少n次
    {n,m} n次到m次
二 修饰符：
    1.g 全局 global
    2.i 忽略大小写
    3.m 换行操作
4.[]的用法：
1）特殊含义的字符（比如：+ .等）不再具有特殊含义，就是普通的字符；
2）中括号不会出现两位数
5.用到|的时候，一定要写小括号； var reg=/^(18|19)$/
6.小括号的用法总结：
1）提高优先级 var reg=/^(18|19)$/
2）分组 经常配合exec；exec拿到的数组中能捕获到小分组；
3）只匹配不捕获 (?:)
7.捕获的方式：
1）exec
2）match:可以一次性把符合我们规则的内容，放在一个新数组返回；
3）replace
8.exec：他可以把捕获到的内容拿出来，每次能到1个；
1)如果能捕获到的话，他的返回值是一个数组，数组有3项：
    1）捕获到1个符合规则的字符
    2）该字符对应的索引
    3）原始字符串
    注意：如果正则中有小括号分组的话，exec拿到的值从数组第二项开始，是我们的小分组；
2）如果捕获不到的话，返回null；
9.正则捕获的特点：
1）懒惰性：解决办法-用全局g;
    eg:每次都是从索引0开始查找；
    用了全局g，lastIndex每次查找都是从找到内容的下一个元素的索引开始查找；

2)贪婪性：解决办法-用?
10.lastIndex:代表开始查找位置的索引；
影响lastIndex的东西有哪些：
    1.exec
    2.test
利用正则这个类的属性RegExp.$1，直接捕获子项，最大能捕获到$9;比$9大就拿不到了；
注意：1）RegExp.$n必须配合test or  exec;(test,exec都属于正则的方法)；
RegExp.$1 拿到的是第一个子项；
RegExp.$2 拿到的是第二个子项；
2）不要再replace中直接使用RegExp.$n,因为RegExp.$n在replace中不兼容；
11.关于?的用法总结：
1）？ 0||1；可有可无的意思
2）用来解决正则捕获的贪婪性 量词元字符+？
3)（?:） 只匹配不捕获；
12.注意，用exec和test，lastIndex等都是正则的方法；
split，search，match，replace等都是字符串的方法；
13.exec和match的区别：
exec能拿到小分组的详细信息；match只能拿到符合大正则的内容，不能拿到小分组的详细信息；
14.replace的实现原理，也是exec；
15.重复子项：
\1：跟第一个小分组一模一样； 小分组都是带小括号的
\2:跟第二个小分组一模一样；









